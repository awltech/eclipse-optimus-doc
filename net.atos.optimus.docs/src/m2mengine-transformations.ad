:title: Writing your own transformations

[cols="a,10a"]
|===
|image:./images/optimus-logo.png[height="128"]|[headertitle]#Writing your own transformations#
|===

''''

== Purpose

We present in this page how to write transformation with the fluent API, available since Optimus 1.2.
This API propose a high level abstraction of the Java Abstract Syntax Tree used by modisco. 
So, the API enable to manipulate concept of the Java language by encapsulate AST object, accessible by the *getDelegate()* method.

Below, we describe how to generate the different concept of the Java language with sample code and we show the associated code produced. 

There is three ways to write transformation on concepts :

	* Use static method in helper for a full customization of the generated concept
	* Build the concept with helper and take profit of some default behaviors.
	* Add directly element to the created concept.

We can generate the following concept of the Java language :

* <<Package>>
* <<Class>>
* <<Interface>>
* <<Import>>
* <<Field>>
* <<Constructor>>


[[Package]]
== Generating Package

To create a package, we need the java model (mainly the source folder) and his full qualified name. 
The already existed package chunk aren't recreated by the method below.

----------
JavaPackage createdPackage = PackageHelper.createPackage(javaModel, "my.generated.javapackage");
----------

== Generating Class, Interface and enumeration

[[Class]]
=== Generating Class

We assume that we created the package above

----------
JavaClass createdClass = ClassHelper.createClass(createdPackage, "MyClass", VisibilityKind.PUBLIC,
				InheritanceKind.NONE, false // proxy_state
				, "SuperClass", "MyImplementedInterface1", "MyImplementedInterface2");
----------

Or with builder :

----------
JavaClass createdClass = ClassHelper.builder(createdPackage, "MyClass").setVisibility(VisibilityKind.PUBLIC)
				.setInheritance(InheritanceKind.NONE).setProxy(false).setSuperClass("SuperClass")
				.addInterfaces("MyImplementedInterface1", "MyImplementedInterface2").build();
----------

Generating code :

----------
package my.generated.javapackage;

public class MyClass extends SuperClass implements MyImplementedInterface1,
		MyImplementedInterface2 {
}
----------

A more complex example with default behavior :

----------
JavaClass createdComplexClass = ClassHelper.builder(createdPackage, "MyComplexClass<T super Object>")
				.setSuperClass("MySuperClass<T>").build();
----------

Generating code :

----------
package my.generated.javapackage;

public class MyComplexClass<T extends Object> extends MySuperClass<T> {
}
----------

==== Generating internal class

We assume that we created the class above

----------
JavaClass createdInternalClass = ClassHelper.createInternalClass(createdClass, "MyInternalClass", VisibilityKind.PUBLIC, InheritanceKind.NONE, false // proxy_state
				, "SuperClass", "MyImplementedInterface1", "MyImplementedInterface2");
----------

Or with builder :

----------
JavaClass createdInternalClass = ClassHelper.internalClassBuilder(createdClass, "MyInternalClass").setVisibility(VisibilityKind.PUBLIC)
				.setInheritance(InheritanceKind.NONE).setProxy(false).setSuperClass("SuperClass")
				.addInterfaces("MyImplementedInterface1", "MyImplementedInterface2").build();
----------

Generating code :

----------
package my.generated.javapackage;

public class MyClass extends SuperClass implements MyImplementedInterface1,
		MyImplementedInterface2 {
	public class MyInternalClass extends SuperClass implements
			MyImplementedInterface1, MyImplementedInterface2 {
	}
}
----------


[[Interface]]
=== Generating Interface

We assume that we created the package above

----------
Interface createdInterface = InterfaceHelper.createInterface(createdPackage, "MyInterface",
				VisibilityKind.PUBLIC, false // abstract_state
				, InheritanceKind.NONE, false // proxy_state
				, "MySuperInterface1", "MySuperInterface2");
----------

Or with builder :

----------
Interface createdInterface = createdInterface = InterfaceHelper.builder(createdPackage, "MyInterface").setVisibility(VisibilityKind.PUBLIC)
				.setAbstract(false).setProxy(false).setInheritance(InheritanceKind.NONE)
				.addInterfaces("MySuperInterface1", "MySuperInterface2").build();
----------

Generating code :

----------
package my.generated.javapackage;

public interface MyInterface extends MySuperInterface1, MySuperInterface2 {
}
----------

A more complex example with default behavior :

----------
Interface createdComplexInterface = InterfaceHelper
				.builder(createdPackage, "MyComplexInterface<T extends Object>")
				.addInterfaces("SuperParametricInterface<Integer>").build();
----------

Generating code :

----------
package my.generated.javapackage;

public interface MyComplexInterface<T extends Object> extends
		SuperParametricInterface<Integer> {
}
----------

[[Import]]
=== Generating Import

We assume that we created classes and the interfaces above. You can add import during the creation process :

----------
JavaClass anotherClass = ClassHelper.builder(createdPackage, "AnotherClass").addImports("java.util.List")
				.addStaticImports("java.util.Collections.*").build();

Interface anotherInterface = InterfaceHelper.builder(createdPackage, "AnotherInterface")
				.addImports("java.util.*", "java.lang.*").addStaticImports("java.util.Collections.*").build();
----------

Or after :

----------
createdClass.addImports("java.util.List").addStaticImports("java.util.Collections.*");
		
createdInterface.addImports("java.util.*", "java.lang.*").addStaticImports("java.util.Collections.*");
----------

Generating code :

----------
// Class
package my.generated.javapackage;

import java.util.List;
import java.util.Collections.*;

public class MyClass extends SuperClass implements MyImplementedInterface1,
		MyImplementedInterface2 {
}

// Interface
package my.generated.javapackage;

import java.util.*;
import java.lang.*;
import java.util.Collections.*;

public interface MyInterface extends MySuperInterface1, MySuperInterface2 {
}
----------

[[Field]]
== Generating Field

We assume that we created classes above.

----------
Field createdField = FieldHelper.createField(createdClass, VisibilityKind.PRIVATE, false // static_state
				, false // final_state
				, "MyFieldType", "myField");

----------

Or with builder :

----------
Field createdAnotherField = FieldHelper.builder(createdClass, "int").setVisibility(VisibilityKind.PRIVATE)
				.setStatic(false).setFinal(false).setName("myOtherField").build();
----------

Generating code :

----------
// Some class code
	private MyFieldType myField;
	private int myOtherField;
// Some class code
----------

A more complex example with default behavior :

----------
Field createdComplexField =  FieldHelper.builder(createdClass, "List<Integer>").build();
----------

Generating code :

----------
// Some class code
	private List<Integer> list;
// Some class code
----------

== Generating method

[[Constructor]]
=== Generating Constructor

We assume that we created classes and fields above.

----------
Constructor createdConstructor = ConstructorHelper.createConstructor(createdClass, VisibilityKind.PUBLIC,
				createdField, createdAnotherField); // Added parameter with auto-generated name and set specified fields
----------

Generating code :

----------
public MyClass(MyFieldType myFieldType, int myInt) {
		this.myField = myFieldType;
		this.myOtherField = myInt;
}
----------

Or with builder :

----------
Constructor createdConstructor = ConstructorHelper.builder(createdClass).setVisibility(VisibilityKind.PUBLIC)
				.addParameterAndSetAssociatedFields(createdField, createdAnotherField) // Added parameter with auto-generated name and set specified fields
				.addExceptions("Exception1","Exception2") // Added exceptions in the builder
				.build();
----------

Generating code :

----------
public MyClass(MyFieldType myFieldType, int myInt) throws Exception1,
			Exception2 {
		this.myField = myFieldType;
		this.myOtherField = myInt;
}
----------

We have additionnal ways to add parameters

----------
Constructor createdAnotherConstructor = ConstructorHelper.builder(createdClass)
				.addParameter("int", "parameter").addParameter("List<Integer>", "parameter2") // Added parameter with specified type and name, no field setting
				.build();

Constructor createdAnotherConstructor2 = ConstructorHelper.builder(createdClass)
				.addParameterAndSetAssociatedField("param1", createdField) // Added parameter with specified name and set specified field
				.addParameterAndSetAssociatedField("param2", createdAnotherField) // Added parameter with specified name and set specified field
				.build();

Constructor createdAnotherConstructor3 = ConstructorHelper.builder(createdClass) 
				.addParameters("int", "List<Integer>") // Added parameter with generated name, no field setting
				.build();
----------

Generating code :

----------
public MyClass(int parameter, List<Integer> parameter2);

public MyClass(MyFieldType param1, int param2){
		this.myField=param1;
		this.myOtherField=param2;
}

public MyClass(int myInt, List<Integer> list);
----------

In the case one and three, you need to had some code in the constructor (see the <<Instruction>> part).

Furthermore, we can add parameters and exceptions after the constructor creation by method with the same name.

[[Instruction]]
== Generating instruction















































----------

----------

Or with builder :

----------

----------

Generating code :

----------

----------

A more complex example with default behavior :

----------

----------

Generating code :

----------

----------








