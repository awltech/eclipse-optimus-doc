:title: Writing your own transformations

[cols="a,10a"]
|===
|image:./images/optimus-logo.png[height="128"]|[headertitle]#Writing your own transformations#
|===

''''

== Purpose

We present in this page how to write transformation with the fluent API, available since Optimus 1.2.
This API propose a high level abstraction of the Java Abstract Syntax Tree used by modisco. 
So, the API enable to manipulate concept of the Java language by encapsulate AST object, accessible by the *getDelegate()* method.

Below, we describe how to generate the different concept of the Java language with sample code and we show the associated code produced. 

There is three ways to write transformation on concepts :

	* Use static method in helper for a full customization of the generated concept
	* Build the concept with helper and take profit of some default behaviors.
	* Add directly element to the created concept.

We can generate the following concept of the Java language :

* <<Package>>
* <<Class>>
* <<Interface>>
* <<Import>>


[[Package]]
== Generating Package

To create a package, we need the java model (mainly the source folder) and his full qualified name. 
The already existed package chunk aren't recreated by the method below.

----------
JavaPackage createdPackage = PackageHelper.createPackage(javaModel, "my.generated.javapackage");
----------

== Generating Class, Interface and enumeration

[[Class]]
=== Generating Class

We assume that we created the package above

----------
JavaClass createdClass = ClassHelper.createClass(createdPackage, "myClass", VisibilityKind.PUBLIC,
				InheritanceKind.NONE, false // proxy_state
				, "SuperClass", "myImplementedInterface1", "myImplementedInterface2");
----------

Or with builder :

----------
JavaClass createdClass = ClassHelper.builder(createdPackage, "myClass").setVisibility(VisibilityKind.PUBLIC)
				.setInheritance(InheritanceKind.NONE).setProxy(false).setSuperClass("SuperClass")
				.addInterfaces("myImplementedInterface1", "myImplementedInterface2").build();
----------

Generating code :

----------
package my.generated.javapackage;

public class myClass extends SuperClass implements myImplementedInterface1,
		myImplementedInterface2 {
}
----------

A more complex example with default behavior :

----------
JavaClass createdComplexClass = ClassHelper.builder(createdPackage, "myComplexClass<T super Object>")
				.setSuperClass("MySuperClass<T>").build();
----------

Generating code :

----------
package my.generated.javapackage;

public class myComplexClass<T extends Object> extends MySuperClass<T> {
}
----------

==== Generating internal class

We assume that we created the class above

----------
JavaClass createdInternalClass = ClassHelper.createInternalClass(createdClass, "myInternalClass", VisibilityKind.PUBLIC, InheritanceKind.NONE, false // proxy_state
				, "SuperClass", "myImplementedInterface1", "myImplementedInterface2");
----------

Or with builder :

----------
JavaClass createdInternalClass = ClassHelper.internalClassBuilder(createdClass, "myInternalClass").setVisibility(VisibilityKind.PUBLIC)
				.setInheritance(InheritanceKind.NONE).setProxy(false).setSuperClass("SuperClass")
				.addInterfaces("myImplementedInterface1", "myImplementedInterface2").build();
----------

Generating code :

----------
package my.generated.javapackage;

public class myClass extends SuperClass implements myImplementedInterface1,
		myImplementedInterface2 {
	public class myInternalClass extends SuperClass implements
			myImplementedInterface1, myImplementedInterface2 {
	}
}
----------


[[Interface]]
=== Generating Interface

We assume that we created the package above

----------
Interface createdInterface = InterfaceHelper.createInterface(createdPackage, "myInterface",
				VisibilityKind.PUBLIC, false // abstract_state
				, InheritanceKind.NONE, false // proxy_state
				, "mySuperInterface1", "mySuperInterface2");
----------

Or with builder :

----------
Interface createdInterface = createdInterface = InterfaceHelper.builder(createdPackage, "myInterface").setVisibility(VisibilityKind.PUBLIC)
				.setAbstract(false).setProxy(false).setInheritance(InheritanceKind.NONE)
				.addInterfaces("mySuperInterface1", "mySuperInterface2").build();
----------

Generating code :

----------
package my.generated.javapackage;

public interface myInterface extends mySuperInterface1, mySuperInterface2 {
}
----------

A more complex example with default behavior :

----------
Interface createdComplexInterface = InterfaceHelper
				.builder(createdPackage, "myComplexInterface<T extends Object>")
				.addInterfaces("SuperParametricInterface<Integer>").build();
----------

Generating code :

----------
package my.generated.javapackage;

public interface myComplexInterface<T extends Object> extends
		SuperParametricInterface<Integer> {
}
----------

[[Import]]
=== Generating Import

We assume that we created classes and the interfaces above. You can add import during the creation process :

----------
JavaClass anotherClass = ClassHelper.builder(createdPackage, "anotherClass").addImports("java.util.List")
				.addStaticImports("java.util.Collections.*").build();

Interface anotherInterface = InterfaceHelper.builder(createdPackage, "anotherInterface")
				.addImports("java.util.*", "java.lang.*").addStaticImports("java.util.Collections.*").build();
----------

Or after :

----------
createdClass.addImports("java.util.List").addStaticImports("java.util.Collections.*");
		
createdInterface.addImports("java.util.*", "java.lang.*").addStaticImports("java.util.Collections.*");
----------

Generating code :

----------
// Class
package my.generated.javapackage;

import java.util.List;
import java.util.Collections.*;

public class myClass extends SuperClass implements myImplementedInterface1,
		myImplementedInterface2 {
}

// Interface
package my.generated.javapackage;

import java.util.*;
import java.lang.*;
import java.util.Collections.*;

public interface myInterface extends mySuperInterface1, mySuperInterface2 {
}
----------














