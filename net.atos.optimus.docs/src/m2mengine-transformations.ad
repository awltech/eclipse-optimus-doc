:title: Writing your own transformations

[cols="a,10a"]
|===
|image:./images/optimus-logo.png[height="128"]|[headertitle]#Writing your own transformations#
|===

''''

== Purpose

We present in this page how to write transformation with the fluent API, available since Optimus 1.2.
This API propose a high level abstraction of the Java Abstract Syntax Tree used by modisco. 
So, the API enable to manipulate concept of the Java language by encapsulate AST object, accessible by the *getDelegate()* method.

Below, we describe how to generate the different concept of the Java language with sample code and we show the associated code produced. 

There is three ways to write transformation on concepts :

	* Use static method in helper for a full customization of the generated concept
	* Build the concept with helper and take profit of some default behaviors.
	* Add directly element to the created concept.

We can generate the following concept of the Java language :

* <<Package>>
* <<AbstractClass>>
** <<Class>>
** <<Interface>>
** <<Enumeration>>
** <<Import>>
* <<Field>>
* <<AbstractMethod>>
** <<Constructor>>
** <<Getter>>
** <<Setter>>
** <<Method>>
* <<Instruction>>


[[Package]]
== Generating Package

To create a package, we need the java model (mainly the source folder) and his full qualified name. 
The already existed package chunk aren't recreated by the method below.

----------
JavaPackage createdPackage = PackageHelper.createPackage(javaModel, "my.generated.javapackage");
----------

[[AbstractClass]]
== Generating Class, Interface and Enumeration

[[Class]]
=== Generating Class

We assume that we created the package above

----------
JavaClass createdClass = ClassHelper.createClass(createdPackage, "MyClass", VisibilityKind.PUBLIC,
				InheritanceKind.NONE, false // proxy_state
				, "SuperClass", "MyImplementedInterface1", "MyImplementedInterface2");
----------

Or with builder :

----------
JavaClass createdClass = ClassHelper.builder(createdPackage, "MyClass").setVisibility(VisibilityKind.PUBLIC)
				.setInheritance(InheritanceKind.NONE).setProxy(false).setSuperClass("SuperClass")
				.addInterfaces("MyImplementedInterface1", "MyImplementedInterface2").build();
----------

Generating code :

----------
package my.generated.javapackage;

public class MyClass extends SuperClass implements MyImplementedInterface1,
		MyImplementedInterface2 {
}
----------

A more complex example with default behavior :

----------
JavaClass createdComplexClass = ClassHelper.builder(createdPackage, "MyComplexClass<T super Object>")
				.setSuperClass("MySuperClass<T>").build();
----------

Generating code :

----------
package my.generated.javapackage;

public class MyComplexClass<T extends Object> extends MySuperClass<T> {
}
----------

==== Generating internal class

We assume that we created the class above

----------
JavaClass createdInternalClass = ClassHelper.createInternalClass(createdClass, "MyInternalClass", VisibilityKind.PUBLIC, InheritanceKind.NONE, false // proxy_state
				, "SuperClass", "MyImplementedInterface1", "MyImplementedInterface2");
----------

Or with builder :

----------
JavaClass createdInternalClass = ClassHelper.internalClassBuilder(createdClass, "MyInternalClass").setVisibility(VisibilityKind.PUBLIC)
				.setInheritance(InheritanceKind.NONE).setProxy(false).setSuperClass("SuperClass")
				.addInterfaces("MyImplementedInterface1", "MyImplementedInterface2").build();
----------

Generating code :

----------
package my.generated.javapackage;

public class MyClass extends SuperClass implements MyImplementedInterface1,
		MyImplementedInterface2 {
	public class MyInternalClass extends SuperClass implements
			MyImplementedInterface1, MyImplementedInterface2 {
	}
}
----------


[[Interface]]
=== Generating Interface

We assume that we created the package above

----------
Interface createdInterface = InterfaceHelper.createInterface(createdPackage, "MyInterface",
				VisibilityKind.PUBLIC, false // abstract_state
				, InheritanceKind.NONE, false // proxy_state
				, "MySuperInterface1", "MySuperInterface2");
----------

Or with builder :

----------
Interface createdInterface = createdInterface = InterfaceHelper.builder(createdPackage, "MyInterface").setVisibility(VisibilityKind.PUBLIC)
				.setAbstract(false).setProxy(false).setInheritance(InheritanceKind.NONE)
				.addInterfaces("MySuperInterface1", "MySuperInterface2").build();
----------

Generating code :

----------
package my.generated.javapackage;

public interface MyInterface extends MySuperInterface1, MySuperInterface2 {
}
----------

A more complex example with default behavior :

----------
Interface createdComplexInterface = InterfaceHelper
				.builder(createdPackage, "MyComplexInterface<T extends Object>")
				.addInterfaces("SuperParametricInterface<Integer>").build();
----------

Generating code :

----------
package my.generated.javapackage;

public interface MyComplexInterface<T extends Object> extends
		SuperParametricInterface<Integer> {
}
----------

[[Enumeration]]
=== Generating Enumeration

We assume that we created the package above

----------
JavaEnum createdEnum = EnumHelper.createEnum(createdPackage, "myEnum", false // proxy_state
				, "MyImplementedInterface1", "MyImplementedInterface2").addEnumConstant("MyConstant");
----------

Or with builder :

----------
createdEnum = EnumHelper.builder(createdPackage, "myEnum").setProxy(false)
				.addInterfaces("MyImplementedInterface1", "MyImplementedInterface2").addEnumConstant("MyConstant").build();
----------

Generating code :

----------
package my.generated.javapackage;

import java.util.List;

public enum myEnum implements MyImplementedInterface1, MyImplementedInterface2 {
	MyConstant();
}
----------

Warning : you must add at least one constant when you create a enumeration or the generation doesn't work properly.
With the *addEnumConstant* methods, you can add list of arguments to an enum constant (see the <<Instruction>> part).

A more complex example with default behavior :

----------
JavaEnum createdComplexEnum = EnumHelper.builder(createdPackage, "myDefaultEnum").addEnumConstant("MyFirstConstant")
				.addEnumConstant("MySecondConstant").addEnumConstant("MyThirdConstant").build();
----------

Generating code :

----------
package my.generated.javapackage;

public enum myDefaultEnum {
	MyFirstConstant(), MySecondConstant(), MyThirdConstant();
}
----------

[[Import]]
=== Generating Import

We assume that we created classes, interfaces and enumerations above. You can add import during the creation process :

----------
JavaClass anotherClass = ClassHelper.builder(createdPackage, "AnotherClass").addImports("java.util.List")
				.addStaticImports("java.util.Collections.*").build();

Interface anotherInterface = InterfaceHelper.builder(createdPackage, "AnotherInterface")
				.addImports("java.util.*", "java.lang.*").addStaticImports("java.util.Collections.*").build();

JavaEnum anotherEnum = EnumHelper.builder(createdPackage, "AnotherEnum")
				.addImports("java.util.*", "java.lang.*").addStaticImports("java.util.Collections.*").build();
----------

Or after :

----------
createdClass.addImports("java.util.List").addStaticImports("java.util.Collections.*");
		
createdInterface.addImports("java.util.*", "java.lang.*").addStaticImports("java.util.Collections.*");

createdEnum.addImports("java.util.*", "java.lang.*").addStaticImports("java.util.Collections.*");
----------

Generating code :

----------
// Class
package my.generated.javapackage;

import java.util.List;
import java.util.Collections.*;

public class MyClass extends SuperClass implements MyImplementedInterface1,
		MyImplementedInterface2 {
}

// Interface
package my.generated.javapackage;

import java.util.*;
import java.lang.*;
import java.util.Collections.*;

public interface MyInterface extends MySuperInterface1, MySuperInterface2 {
}

// Enum
package my.generated.javapackage;

import java.util.*;
import java.lang.*;
import java.util.Collections.*;

public enum myEnum implements MyImplementedInterface1, MyImplementedInterface2 {
}
----------

[[Field]]
== Generating Field

We assume that we created classes and enumerations above.

----------
Field createdField = FieldHelper.createField(createdClass, VisibilityKind.PRIVATE, false // static_state
				, false // final_state
				, "MyFieldType", "myField");

----------

Or with builder :

----------
Field createdAnotherField = FieldHelper.builder(createdClass, "int").setVisibility(VisibilityKind.PRIVATE)
				.setStatic(false).setFinal(false).setName("myOtherField").build();
----------

Generating code :

----------
// Some class code
	private MyFieldType myField;
	private int myOtherField;
// Some class code
----------

A more complex example with default behavior :

----------
Field createdComplexField =  FieldHelper.builder(createdEnum, "List<Integer>").build();
----------

Generating code :

----------
// Some enum code
	private List<Integer> list;
// Some enum code
----------

[[AbstractMethod]]
== Generating Constructor and Method

[[Constructor]]
=== Generating Constructor

We assume that we created classes, enumerations and fields above.

----------
Constructor createdConstructor = ConstructorHelper.createConstructor(createdClass, VisibilityKind.PUBLIC,
				createdField, createdAnotherField); // Added parameter with auto-generated name and set specified fields
----------

Generating code :

----------
public MyClass(MyFieldType myFieldType, int myInt) {
	this.myField = myFieldType;
	this.myOtherField = myInt;
}
----------

Or with builder :

----------
Constructor createdConstructor = ConstructorHelper.builder(createdEnum).setVisibility(VisibilityKind.PUBLIC)
				.addParameterAndSetAssociatedFields(createdField, createdAnotherField) // Added parameter with auto-generated name and set specified fields
				.addExceptions("Exception1","Exception2") // Added exceptions in the builder
				.build();
----------

Generating code :

----------
public myEnum(MyFieldType myFieldType, int myInt) throws Exception1,
			Exception2 {
		this.myField = myFieldType;
		this.myOtherField = myInt;
}
----------

We have additional ways to add parameters

----------
Constructor createdAnotherConstructor = ConstructorHelper.builder(createdClass)
				.addParameter("int", "parameter").addParameter("List<Integer>", "parameter2") // Added parameter with specified type and name, no field setting
				.build();

Constructor createdAnotherConstructor2 = ConstructorHelper.builder(createdClass)
				.addParameterAndSetAssociatedField("param1", createdField) // Added parameter with specified name and set specified field
				.addParameterAndSetAssociatedField("param2", createdAnotherField) // Added parameter with specified name and set specified field
				.build();

Constructor createdAnotherConstructor3 = ConstructorHelper.builder(createdClass) 
				.addParameters("int", "List<Integer>") // Added parameter with generated name, no field setting
				.build();
----------

Generating code :

----------
public MyClass(int parameter, List<Integer> parameter2);

public MyClass(MyFieldType param1, int param2){
	this.myField=param1;
	this.myOtherField=param2;
}

public MyClass(int myInt, List<Integer> list);
----------

In the case one and three, you need to add some code in the constructor body (see the <<Instruction>> part).

Furthermore, we can add parameters and exceptions after the constructor creation by method with the same name.

[[Getter]]
=== Generating Getter

We assume that we created classes and fields above.

----------
Method getter = GetterHelper.createGetter(createdClass, VisibilityKind.PUBLIC, false // final_state
				, createdField, "getField");
----------

Or with builder :

----------
Method getter = GetterHelper.builder(createdEnum, createdField).setVisibility(VisibilityKind.PUBLIC).setFinal(false)
				.setName("getField").build();
----------

Generating code :

----------
public MyFieldType getField() {
	return this.myField;
}
----------

Another example with default behavior (auto-generated name) :

----------
Method anotherGetter = GetterHelper.builder(createdClass, createdField).build();
----------

Generating code :

----------
public MyFieldType getMyField() {
	return this.myField;
}
----------

[[Setter]]
=== Generating Setter

We assume that we created classes, enumerations and fields above.

----------
Method setter = SetterHelper.createSetter(createdClass, VisibilityKind.PUBLIC, false // final_state
				, createdAnotherField, "setField", "parameter");
----------

Or with builder :

----------
Method setter = SetterHelper.builder(createdClass, createdAnotherField).setVisibility(VisibilityKind.PUBLIC)
				.setFinal(false).setName("setField").setParameterName("parameter").build();
----------

Generating code :

----------
public void setField(int parameter) {
	this.myOtherField = parameter;
}
----------

Another example with default behavior (auto-generated name and parameter name) :

----------
Method setter = SetterHelper.builder(createdEnum, createdAnotherField).build();
----------

Generating code :

----------
public void setMyOtherField(int myInt) {
	this.myOtherField = myInt;
}
----------

[[Method]]
=== Generating Method

We assume that we created classes, interfaces and enumerations above. We can add method to a class, an interface or an enumeration.

----------
Method method = MethodHelper.createMethod(createdInterface, VisibilityKind.PUBLIC, false // static_state
				, InheritanceKind.NONE, "int[]", "aMethod", "Exception1", "Exception2");
----------

Or with builder :

----------
Method method = MethodHelper.builder(createdClass, "aMethod").setVisibility(VisibilityKind.PUBLIC)
				.setStatic(false).setInheritance(InheritanceKind.NONE).setReturnType("int[]")
				.addExceptions("Exception1", "Exception2").build();
----------

Generating code :

----------
public int[] aMethod() throws Exception1, Exception2;
----------

We have additional ways to add parameters

----------
Method createdAnotherMethod = MethodHelper.builder(createdEnum, "anotherMethod")
				.addParameter("int", "parameter").addParameter("List<Integer>", "parameter2").build();

Method createdAnotherMethod2 = MethodHelper.builder(createdClass, "anotherMethod2")
				.addParameters("int", "List<Integer>")
				.build();
----------

Generating code :

----------
public void anotherMethod(int parameter, List<Integer> parameter2);

public void anotherMethod2(int myInt, List<Integer> list);
----------

When you add a non abstract method to a class, you need to add some code in the method body (see the <<Instruction>> part).

Furthermore, we can add parameters and exceptions after the constructor creation by method with the same name.

Another example with default behavior :

----------
Method defaultMethod = MethodHelper.builder(createdClass, "aComplexMethod").build();
----------

Generating code :

----------
public void aComplexMethod();
----------

Another complex example, generic method and array parameters  :

----------
Method genericMethod = MethodHelper.builder(createdClass, "genericMethod")
				.setReturnType("<T super Collection<?>> List<S>").addParameter("T[]", "arrayParam")
				.addParameter("Collection<Object>[]", "complexArrayParam").build();
----------

Generating code :

----------
public <T extends Collection<?>> List<S> genericMethod(T[] arrayParam, Collection<Object>[] complexArrayParam);
----------

[[Instruction]]
== Generating Instruction















































----------

----------

Or with builder :

----------

----------

Generating code :

----------

----------

A more complex example with default behavior :

----------

----------

Generating code :

----------

----------








