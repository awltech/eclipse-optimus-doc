:title: Writing your own transformations

[cols="a,10a"]
|===
|image:./images/optimus-logo.png[height="128"]|[headertitle]#Writing your own transformations#
|===

''''

== Purpose

We present in this page how to write transformation with the fluent API, available since Optimus 1.2, in the plugin *net.atos.optimus.m2m.javaxmi.operation*.
This API propose a high level abstraction of the Java Abstract Syntax Tree used by modisco. 
So, the API enable to manipulate concept of the Java language by encapsulate AST object, accessible by the *getDelegate()* method.

Below, we describe how to generate the different concept of the Java language with sample code and we show the associated code produced. 

There is three ways to write transformation on concepts :

	* Use static method in helper for a full customization of the generated concept
	* Build the concept with helper and take profit of some default behaviors.
	* Add directly element to the created concept.

We can generate the following concept of the Java language :

* <<Package>>
* <<AbstractClass>>
** <<Class>>
** <<Interface>>
** <<Enumeration>>
** <<Import>>
* <<Field>>
* <<AbstractMethod>>
** <<Constructor>>
** <<Getter>>
** <<Setter>>
** <<Method>>
* <<Instruction>>
** <<Constant>>
** <<Field/Variable>>
*** <<VarDecl>>
** <<Array>>
** <<Operation>>
*** <<Prefix>>
*** <<Postfix>>
*** <<Infix>>
** <<Assignment>>
*** <<Assignment/Declaration>>
** <<Creation>>
*** <<ArrayCreation>>
*** <<ClassCreation>>
** <<MethodCall>>
** <<Argument>>
** <<Return>>
** <<Control>>
*** <<If>>
*** <<Switch>>
*** <<While>>
*** <<ForLoop>>
*** <<ForIterable>>
*** <<Try/Catch>>
** <<OtherInst>>
*** <<Parenthesis>>
*** <<InstanceOf>>
*** <<Cast>>

[[Package]]
== Generating Package

To create a package, we need the java model (mainly the source folder) and his full qualified name. 
The already existed package chunk aren't recreated by the method below.

----------
JavaPackage createdPackage = PackageHelper.createPackage(javaModel, "my.generated.javapackage");
----------

[[AbstractClass]]
== Generating Class, Interface and Enumeration

[[Class]]
=== Generating Class

We assume that we created the package above

----------
JavaClass createdClass = ClassHelper.createClass(createdPackage, "MyClass", VisibilityKind.PUBLIC,
				InheritanceKind.NONE, false // proxy_state
				, "SuperClass", "MyImplementedInterface1", "MyImplementedInterface2");
----------

Or with builder :

----------
JavaClass createdClass = ClassHelper.builder(createdPackage, "MyClass").setVisibility(VisibilityKind.PUBLIC)
				.setInheritance(InheritanceKind.NONE).setProxy(false).setSuperClass("SuperClass")
				.addInterfaces("MyImplementedInterface1", "MyImplementedInterface2").build();
----------

Generating code :

----------
package my.generated.javapackage;

public class MyClass extends SuperClass implements MyImplementedInterface1,
		MyImplementedInterface2 {
}
----------

A more complex example with default behavior :

----------
JavaClass createdComplexClass = ClassHelper.builder(createdPackage, "MyComplexClass<T super Object>")
				.setSuperClass("MySuperClass<T>").build();
----------

Generating code :

----------
package my.generated.javapackage;

public class MyComplexClass<T extends Object> extends MySuperClass<T> {
}
----------

==== Generating internal class

We assume that we created the class above

----------
JavaClass createdInternalClass = ClassHelper.createInternalClass(createdClass, "MyInternalClass", VisibilityKind.PUBLIC, InheritanceKind.NONE, false // proxy_state
				, "SuperClass", "MyImplementedInterface1", "MyImplementedInterface2");
----------

Or with builder :

----------
JavaClass createdInternalClass = ClassHelper.internalClassBuilder(createdClass, "MyInternalClass").setVisibility(VisibilityKind.PUBLIC)
				.setInheritance(InheritanceKind.NONE).setProxy(false).setSuperClass("SuperClass")
				.addInterfaces("MyImplementedInterface1", "MyImplementedInterface2").build();
----------

Generating code :

----------
package my.generated.javapackage;

public class MyClass extends SuperClass implements MyImplementedInterface1,
		MyImplementedInterface2 {
	public class MyInternalClass extends SuperClass implements
			MyImplementedInterface1, MyImplementedInterface2 {
	}
}
----------


[[Interface]]
=== Generating Interface

We assume that we created the package above

----------
Interface createdInterface = InterfaceHelper.createInterface(createdPackage, "MyInterface",
				VisibilityKind.PUBLIC, false // abstract_state
				, InheritanceKind.NONE, false // proxy_state
				, "MySuperInterface1", "MySuperInterface2");
----------

Or with builder :

----------
Interface createdInterface = createdInterface = InterfaceHelper.builder(createdPackage, "MyInterface").setVisibility(VisibilityKind.PUBLIC)
				.setAbstract(false).setProxy(false).setInheritance(InheritanceKind.NONE)
				.addInterfaces("MySuperInterface1", "MySuperInterface2").build();
----------

Generating code :

----------
package my.generated.javapackage;

public interface MyInterface extends MySuperInterface1, MySuperInterface2 {
}
----------

A more complex example with default behavior :

----------
Interface createdComplexInterface = InterfaceHelper
				.builder(createdPackage, "MyComplexInterface<T extends Object>")
				.addInterfaces("SuperParametricInterface<Integer>").build();
----------

Generating code :

----------
package my.generated.javapackage;

public interface MyComplexInterface<T extends Object> extends
		SuperParametricInterface<Integer> {
}
----------

[[Enumeration]]
=== Generating Enumeration

We assume that we created the package above

----------
JavaEnum createdEnum = EnumHelper.createEnum(createdPackage, "myEnum", false // proxy_state
				, "MyImplementedInterface1", "MyImplementedInterface2").addEnumConstant("MyConstant");
----------

Or with builder :

----------
createdEnum = EnumHelper.builder(createdPackage, "myEnum").setProxy(false)
				.addInterfaces("MyImplementedInterface1", "MyImplementedInterface2").addEnumConstant("MyConstant").build();
----------

Generating code :

----------
package my.generated.javapackage;

import java.util.List;

public enum myEnum implements MyImplementedInterface1, MyImplementedInterface2 {
	MyConstant();
}
----------

Warning : you must add at least one constant when you create a enumeration or the generation doesn't work properly.
With the *addEnumConstant* methods, you can add list of arguments to an enum constant (see the <<Instruction>> part).

A more complex example with default behavior :

----------
JavaEnum createdComplexEnum = EnumHelper.builder(createdPackage, "myDefaultEnum").addEnumConstant("MyFirstConstant")
				.addEnumConstant("MySecondConstant").addEnumConstant("MyThirdConstant").build();
----------

Generating code :

----------
package my.generated.javapackage;

public enum myDefaultEnum {
	MyFirstConstant(), MySecondConstant(), MyThirdConstant();
}
----------

[[Import]]
=== Generating Import

We assume that we created classes, interfaces and enumerations above. You can add import during the creation process :

----------
JavaClass anotherClass = ClassHelper.builder(createdPackage, "AnotherClass").addImports("java.util.List")
				.addStaticImports("java.util.Collections.*").build();

Interface anotherInterface = InterfaceHelper.builder(createdPackage, "AnotherInterface")
				.addImports("java.util.*", "java.lang.*").addStaticImports("java.util.Collections.*").build();

JavaEnum anotherEnum = EnumHelper.builder(createdPackage, "AnotherEnum")
				.addImports("java.util.*", "java.lang.*").addStaticImports("java.util.Collections.*").build();
----------

Or after :

----------
createdClass.addImports("java.util.List").addStaticImports("java.util.Collections.*");
		
createdInterface.addImports("java.util.*", "java.lang.*").addStaticImports("java.util.Collections.*");

createdEnum.addImports("java.util.*", "java.lang.*").addStaticImports("java.util.Collections.*");
----------

Generating code :

----------
// Class
package my.generated.javapackage;

import java.util.List;
import java.util.Collections.*;

public class MyClass extends SuperClass implements MyImplementedInterface1,
		MyImplementedInterface2 {
}

// Interface
package my.generated.javapackage;

import java.util.*;
import java.lang.*;
import java.util.Collections.*;

public interface MyInterface extends MySuperInterface1, MySuperInterface2 {
}

// Enum
package my.generated.javapackage;

import java.util.*;
import java.lang.*;
import java.util.Collections.*;

public enum myEnum implements MyImplementedInterface1, MyImplementedInterface2 {
}
----------

[[Field]]
== Generating Field

We assume that we created classes and enumerations above.

----------
Field createdField = FieldHelper.createField(createdClass, VisibilityKind.PRIVATE, false // static_state
				, false // final_state
				, "MyFieldType", "myField");

----------

Or with builder :

----------
Field createdAnotherField = FieldHelper.builder(createdClass, "int").setVisibility(VisibilityKind.PRIVATE)
				.setStatic(false).setFinal(false).setName("myOtherField").build();
----------

Generating code :

----------
// Some class code
	private MyFieldType myField;
	private int myOtherField;
// Some class code
----------

A more complex example with default behavior :

----------
Field createdComplexField =  FieldHelper.builder(createdEnum, "List<Integer>").build();
----------

Generating code :

----------
// Some enum code
	private List<Integer> list;
// Some enum code
----------

[[AbstractMethod]]
== Generating Constructor and Method

[[Constructor]]
=== Generating Constructor

We assume that we created classes, enumerations and fields above.

----------
Constructor createdConstructor = ConstructorHelper.createConstructor(createdClass, VisibilityKind.PUBLIC,
				createdField, createdAnotherField); // Added parameter with auto-generated name and set specified fields
----------

Generating code :

----------
public MyClass(MyFieldType myFieldType, int myInt) {
	this.myField = myFieldType;
	this.myOtherField = myInt;
}
----------

Or with builder :

----------
Constructor createdConstructor = ConstructorHelper.builder(createdEnum).setVisibility(VisibilityKind.PUBLIC)
				.addParameterAndSetAssociatedFields(createdField, createdAnotherField) // Added parameter with auto-generated name and set specified fields
				.addExceptions("Exception1","Exception2") // Added exceptions in the builder
				.build();
----------

Generating code :

----------
public myEnum(MyFieldType myFieldType, int myInt) throws Exception1,
			Exception2 {
		this.myField = myFieldType;
		this.myOtherField = myInt;
}
----------

We have additional ways to add parameters

----------
Constructor createdAnotherConstructor = ConstructorHelper.builder(createdClass)
				.addParameter("int", "parameter").addParameter("List<Integer>", "parameter2") // Added parameter with specified type and name, no field setting
				.build();

Constructor createdAnotherConstructor2 = ConstructorHelper.builder(createdClass)
				.addParameterAndSetAssociatedField("param1", createdField) // Added parameter with specified name and set specified field
				.addParameterAndSetAssociatedField("param2", createdAnotherField) // Added parameter with specified name and set specified field
				.build();

Constructor createdAnotherConstructor3 = ConstructorHelper.builder(createdClass) 
				.addParameters("int", "List<Integer>") // Added parameter with generated name, no field setting
				.build();
----------

Generating code :

----------
public MyClass(int parameter, List<Integer> parameter2);

public MyClass(MyFieldType param1, int param2){
	this.myField=param1;
	this.myOtherField=param2;
}

public MyClass(int myInt, List<Integer> list);
----------

In the case one and three, you need to add some code in the constructor body (see the <<Instruction>> part).

Furthermore, we can add parameters and exceptions after the constructor creation by method with the same name.

[[Getter]]
=== Generating Getter

We assume that we created classes and fields above.

----------
Method getter = GetterHelper.createGetter(createdClass, VisibilityKind.PUBLIC, false // final_state
				, createdField, "getField");
----------

Or with builder :

----------
Method getter = GetterHelper.builder(createdEnum, createdField).setVisibility(VisibilityKind.PUBLIC).setFinal(false)
				.setName("getField").build();
----------

Generating code :

----------
public MyFieldType getField() {
	return this.myField;
}
----------

Another example with default behavior (auto-generated name) :

----------
Method anotherGetter = GetterHelper.builder(createdClass, createdField).build();
----------

Generating code :

----------
public MyFieldType getMyField() {
	return this.myField;
}
----------

[[Setter]]
=== Generating Setter

We assume that we created classes, enumerations and fields above.

----------
Method setter = SetterHelper.createSetter(createdClass, VisibilityKind.PUBLIC, false // final_state
				, createdAnotherField, "setField", "parameter");
----------

Or with builder :

----------
Method setter = SetterHelper.builder(createdClass, createdAnotherField).setVisibility(VisibilityKind.PUBLIC)
				.setFinal(false).setName("setField").setParameterName("parameter").build();
----------

Generating code :

----------
public void setField(int parameter) {
	this.myOtherField = parameter;
}
----------

Another example with default behavior (auto-generated name and parameter name) :

----------
Method setter = SetterHelper.builder(createdEnum, createdAnotherField).build();
----------

Generating code :

----------
public void setMyOtherField(int myInt) {
	this.myOtherField = myInt;
}
----------

[[Method]]
=== Generating Method

We assume that we created classes, interfaces and enumerations above. We can add method to a class, an interface or an enumeration.

----------
Method method = MethodHelper.createMethod(createdInterface, VisibilityKind.PUBLIC, false // static_state
				, InheritanceKind.NONE, "int[]", "aMethod", "Exception1", "Exception2");
----------

Or with builder :

----------
Method method = MethodHelper.builder(createdClass, "aMethod").setVisibility(VisibilityKind.PUBLIC)
				.setStatic(false).setInheritance(InheritanceKind.NONE).setReturnType("int[]")
				.addExceptions("Exception1", "Exception2").build();
----------

Generating code :

----------
public int[] aMethod() throws Exception1, Exception2;
----------

We have additional ways to add parameters

----------
Method createdAnotherMethod = MethodHelper.builder(createdEnum, "anotherMethod")
				.addParameter("int", "parameter").addParameter("List<Integer>", "parameter2").build();

Method createdAnotherMethod2 = MethodHelper.builder(createdClass, "anotherMethod2")
				.addParameters("int", "List<Integer>")
				.build();
----------

Generating code :

----------
public void anotherMethod(int parameter, List<Integer> parameter2);

public void anotherMethod2(int myInt, List<Integer> list);
----------

When you add a non abstract method to a class, you need to add some code in the method body (see the <<Instruction>> part).

Furthermore, we can add parameters and exceptions after the constructor creation by method with the same name.

Another example with default behavior :

----------
Method defaultMethod = MethodHelper.builder(createdClass, "aComplexMethod").build();
----------

Generating code :

----------
public void aComplexMethod();
----------

Another complex example, generic method and array parameters  :

----------
Method genericMethod = MethodHelper.builder(createdClass, "genericMethod")
				.setReturnType("<T super Collection<?>> List<S>").addParameter("T[]", "arrayParam")
				.addParameter("Collection<Object>[]", "complexArrayParam").build();
----------

Generating code :

----------
public <T extends Collection<?>> List<S> genericMethod(T[] arrayParam, Collection<Object>[] complexArrayParam);
----------

[[Instruction]]
== Generating Instruction

A created instruction must be added to an abstract method via the *addInstructions()* method in order to appear during the generation process.
We can't reuse an instruction and only specific instruction can be added to a method.
Indeed, elementary instructions have no sense alone.

[[Constant]]
=== Generating Constant Instruction

----------
ElementaryInstructionHelper.createInstruction(false); // false boolean
ElementaryInstructionHelper.createInstruction(5); // 5 integer
ElementaryInstructionHelper.createInstruction('c'); // 'c' character
ElementaryInstructionHelper.createInstruction("bar"); // "bar" String
ElementaryInstructionHelper.createNullInstruction(); // null
----------

[[Field/Variable]]
=== Generating This, Field, Variable Instruction

Generating the this keyword :

----------
ElementaryInstructionHelper.createThisInstruction(); // this (access to current object)
----------

Generating an access to a variable :

----------
ElementaryInstructionHelper.createVariableInstruction("myVar"); // myVar (access to a variable)
----------

Generating an access to a field :

----------
ElementaryInstructionHelper.createFieldInstruction("myField"); // this.myField (access to a field)
----------

[[VarDecl]]
==== Generating Variable Declaration

----------
ComplexInstruction inst1 = VariableDeclarationHelper.builder("int", "myVariable").build();

ComplexInstruction inst2 = VariableDeclarationHelper.builder("List<Object>", "myList").setFinal(true).build();

ComplexInstruction inst3 = VariableDeclarationHelper.builder("String", "aString")
			.addVariable("anotherString", "aStringAgain").build();
----------

Generating code :

----------
int myVariable;

final List<Object> myList;

String aString, anotherString, aStringAgain;
----------

[[Array]]
=== Generating Array Instruction

Access to an index of a field array :

----------
ArrayInstructionHelper.builderWithField("myArrayField").addIndex(5, 2).build();

// this.myArrayField[5][2]
----------

Access to an index holding by fields and variables in a variable array :

----------
ArrayInstructionHelper.builderWithVariable("myArrayVariable")
			.addFieldIndex("fieldIndex", "fieldIndex2").addVariableIndex("variableIndex1", "variableIndex2")
			.build();

// myArrayVariable[this.fieldIndex][this.fieldIndex2][variableIndex1][variableIndex2]
----------

Access to an index giving by a method return in a array returning by another method :

----------
ArrayInstructionHelper
			.builder(CallInstructionHelper.createThisMethodCallInstruction("getArray"))
			.addIndex(CallInstructionHelper.createThisMethodCallInstruction("getIndex")).build();
				
// this.getArray()[this.getIndex()]
----------

You can replace the calling instruction by any other *IElementary* instruction.

[[Operation]]
=== Generating Operation Instruction

[[Prefix]]
==== Generating Prefix Operation

Prefix operation with boolean constant :

----------
Instruction inst1 = PrefixOperationHelper.builder().setOperator(PrefixExpressionKind.NOT).setOperand(true).build();
// !true
----------

Prefix operation with field and array field :

----------
Instruction inst2 = PrefixOperationHelper.builder().setOperator(PrefixExpressionKind.INCREMENT).setFieldOperand("myField")
			.build();
// ++this.myField

Instruction inst3 = PrefixOperationHelper.builder().setOperator(PrefixExpressionKind.DECREMENT)
			.setFieldArrayOperand("myArrayField", 3, 2).build();
// --this.myArrayField[3][2]

Instruction inst4 = PrefixOperationHelper.builder().setOperator(PrefixExpressionKind.DECREMENT)
			.setFieldArrayOperand("myArrayField", "i", "j").build();
// --this.myArrayField[i][j]
----------

Prefix operation with variable and array variable :

----------
Instruction inst5 = PrefixOperationHelper.builder().setOperator(PrefixExpressionKind.DECREMENT)
			.setVariableOperand("myVariable").build();
// --myVariable

Instruction inst6 = PrefixOperationHelper.builder().setOperator(PrefixExpressionKind.INCREMENT)
			.setVariableArrayOperand("myArrayVariable", 3, 2).build();
// ++myArrayVariable[3][2]

Instruction inst7 = PrefixOperationHelper.builder().setOperator(PrefixExpressionKind.INCREMENT)
	 		.setVariableArrayOperand("myArrayVariable", "i", "j").build();
// ++myArrayVariable[i][j]
----------

Prefix operation in most general case :

----------
Instruction inst8 = PrefixOperationHelper.builder().setOperator(PrefixExpressionKind.NOT)
			.setOperand(CallInstructionHelper.createThisMethodCallInstruction("isSomething")).build();
// !this.isSomething()
----------

You can replace the calling instruction by any other *IElementary* instruction.

[[Postfix]]
==== Generating Postfix Operation

Postfix operation with field and array field :

----------
Instruction inst1 = PostfixOperationHelper.builder().setOperator(PostfixExpressionKind.INCREMENT).setFieldOperand("myField")
				.build();
// this.myField++

Instruction inst2 = PostfixOperationHelper.builder().setOperator(PostfixExpressionKind.DECREMENT)
				.setFieldArrayOperand("myArrayField", 3, 2).build();
// this.myArrayField[3][2]--

Instruction inst3 = PostfixOperationHelper.builder().setOperator(PostfixExpressionKind.DECREMENT)
				.setFieldArrayOperand("myArrayField", "i", "j").build();
// this.myArrayField[i][j]--
----------

Postfix operation with variable and array variable :

----------
Instruction inst4 = PostfixOperationHelper.builder().setOperator(PostfixExpressionKind.DECREMENT)
				.setVariableOperand("myVariable").build();
// myVariable--

Instruction inst5 = PostfixOperationHelper.builder().setOperator(PostfixExpressionKind.INCREMENT)
				.setVariableArrayOperand("myArrayVariable", 3, 2).build();
// myArrayVariable[3][2]++

Instruction inst6 = PostfixOperationHelper.builder().setOperator(PostfixExpressionKind.INCREMENT)
				.setVariableArrayOperand("myArrayVariable", "i", "j").build();
// myArrayVariable[i][j]++
----------

Postfix operation in most general case :

----------
Instruction inst7 = PostfixOperationHelper.builder().setOperator(PostfixExpressionKind.INCREMENT)
			.setOperand(CallInstructionHelper.createThisMethodCallInstruction("getIncrementableObject")).build();
// this.getIncrementableObject()++
----------

You can replace the calling instruction by any other *IElementary* instruction.

[[Infix]]
==== Generating Infix Operation

Infix operation with constant :

----------
ElementaryInstruction inst1 = InfixOperationHelper.builder().setOperator(InfixExpressionKind.PLUS).setLeftOperand('f')
			.setRightOperand("oo").build();
// 'f' + "oo"

ElementaryInstruction inst2 = InfixOperationHelper.builder().setOperator(InfixExpressionKind.PLUS).setLeftOperand("ba")
			.setRightOperand('r').build();
// "ba"+'r'

ElementaryInstruction inst3 = InfixOperationHelper.builder().setOperator(InfixExpressionKind.AND)
			.setLeftOperand(true).setRightOperand(false).build();
// true & false

ElementaryInstruction inst4 = InfixOperationHelper.builder().setOperator(InfixExpressionKind.MINUS)
			.setLeftOperand(42).setRightOperand(24).build();
// 42 - 24
----------

Infix operation with field and array field :

----------
ElementaryInstruction inst5 = InfixOperationHelper.builder().setOperator(InfixExpressionKind.NOT_EQUALS).setLeftThisOperand()
			.setRightThisOperand().build();
// this != this
				
ElementaryInstruction inst6 = InfixOperationHelper.builder().setOperator(InfixExpressionKind.DIVIDE).setLeftFieldOperand("myField")
			.setRightFieldArrayOperand("myArrayField", 5, 5).build();
// this.myField / this.myArrayField[5][5]

ElementaryInstruction inst7 = InfixOperationHelper.builder().setOperator(InfixExpressionKind.TIMES)
			.setLeftFieldArrayOperand("myArrayField", 3, 2)
			.setRightFieldArrayOperand("myOtherArrayField", "i", "j").build();
// this.myArrayField[3][2] * this.myOtherArrayField[i][j]

ElementaryInstruction inst8 = InfixOperationHelper.builder().setOperator(InfixExpressionKind.MINUS)
			.setLeftFieldArrayOperand("myArrayField", "i", "j").setRightFieldOperand("myField").build();
// this.myArrayField[i][j] - this.myField
----------

Infix operation with variable and array variable :

----------
ElementaryInstruction inst9 = InfixOperationHelper.builder().setOperator(InfixExpressionKind.DIVIDE)
			.setLeftVariableOperand("myVariable").setRightVariableArrayOperand("myArrayVariable", 5, 5).build();
// myVariable / myArrayVariable[5][5]

ElementaryInstruction inst10 = InfixOperationHelper.builder().setOperator(InfixExpressionKind.TIMES)
			.setLeftVariableArrayOperand("myArrayVariable", 3, 2)
			.setRightVariableArrayOperand("myOtherArrayVariable", "i", "j").build();
// myArrayVariable[3][2] * myOtherArrayVariable[i][j]

ElementaryInstruction inst11 = InfixOperationHelper.builder().setOperator(InfixExpressionKind.MINUS)
			.setLeftVariableArrayOperand("myArrayVariable", "i", "j").setRightVariableOperand("myVariable").build();
// myArrayVariable[i][j] - myVariable
----------

Infix operation in most general case :

----------
ElementaryInstruction inst12 = InfixOperationHelper.builder().setOperator(InfixExpressionKind.GREATER_EQUALS)
			.setLeftOperand(CallInstructionHelper.createThisMethodCallInstruction("returnSomething"))
			.setRightOperand(CallInstructionHelper.createThisMethodCallInstruction("returnSomethingElse")).build();
// this.returnSomething() >= this.returnSomethingElse()
----------

You can replace calling instructions by any other *IElementary* instructions.

[[Assignment]]
=== Generating Assignment Instruction

Assignment instruction with constant :

----------
Instruction inst1 = AssignmentInstructionHelper.builder().setOperator(AssignmentKind.ASSIGN)
			.setLeftVariableOperand("myVariable").setRightOperand(false).build();

Instruction inst2 = AssignmentInstructionHelper.builder().setOperator(AssignmentKind.ASSIGN)
			.setLeftVariableOperand("myVariable").setRightOperand('r').build();

Instruction inst3 = AssignmentInstructionHelper.builder().setOperator(AssignmentKind.ASSIGN)
			.setLeftVariableOperand("myVariable").setRightOperand("foobar").build();

Instruction inst4 = AssignmentInstructionHelper.builder().setOperator(AssignmentKind.ASSIGN)
			.setLeftVariableOperand("myVariable").setRightOperand(42).build();
----------

Generating code :

----------
myVariable = false;

myVariable = 'r';

myVariable = "foobar";

myVariable = 42;
----------

Assignment instruction with field and array field :

----------
Instruction inst5 = AssignmentInstructionHelper.builder().setOperator(AssignmentKind.ASSIGN).setLeftThisOperand()
			.setRightThisOperand().build();
				
Instruction inst6 = AssignmentInstructionHelper.builder().setOperator(AssignmentKind.PLUS_ASSIGN)
			.setLeftFieldOperand("myField").setRightFieldArrayOperand("myArrayField", 5, 5).build();

Instruction inst7 = AssignmentInstructionHelper.builder().setOperator(AssignmentKind.MINUS_ASSIGN)
			.setLeftFieldArrayOperand("myArrayField", 3, 2)
			.setRightFieldArrayOperand("myOtherArrayField", "i", "j").build();

Instruction inst8 = AssignmentInstructionHelper.builder().setOperator(AssignmentKind.TIMES_ASSIGN)
			.setLeftFieldArrayOperand("myArrayField", "i", "j").setRightFieldOperand("myField").build();
----------

Generating code :

----------
this = this;

this.myField += this.myArrayField[5][5];

this.myArrayField[3][2] -= this.myOtherArrayField[i][j];

this.myArrayField[i][j] *= this.myField;
----------

Assignment instruction with variable and array variable :

----------
Instruction inst9 = AssignmentInstructionHelper.builder().setOperator(AssignmentKind.PLUS_ASSIGN)
			.setLeftVariableOperand("myVariable").setRightVariableArrayOperand("myArrayVariable", 5, 5).build();

Instruction inst10 = AssignmentInstructionHelper.builder().setOperator(AssignmentKind.MINUS_ASSIGN)
			.setLeftVariableArrayOperand("myArrayVariable", 3, 2)
			.setRightVariableArrayOperand("myOtherArrayVariable", "i", "j").build();

Instruction inst11 = AssignmentInstructionHelper.builder().setOperator(AssignmentKind.TIMES_ASSIGN)
			.setLeftVariableArrayOperand("myArrayVariable", "i", "j").setRightVariableOperand("myVariable").build();
----------

Generating code :

----------
myVariable += myArrayVariable[5][5];

myArrayVariable[3][2] -= myOtherArrayVariable[i][j];

myArrayVariable[i][j] *= myVariable;
----------

Assignment instruction in most general case :

----------
Instruction inst12 = AssignmentInstructionHelper.builder().setOperator(AssignmentKind.DIVIDE_ASSIGN)
			.setLeftOperand(CallInstructionHelper.createThisMethodCallInstruction("getAssignableObject"))
			.setRightOperand(CallInstructionHelper.createThisMethodCallInstruction("returnSomething")).build();
----------

Generating code :

----------
this.getAssignableObject() /= this.returnSomething();
----------

You can replace calling instructions by any other *IElementary* instructions.

[[Assignment/Declaration]]
==== Generating Variable Declaration with Assignment

----------
Instruction inst13 = AssignmentInstructionHelper.builder().setOperator(AssignmentKind.ASSIGN)
			.setLeftVariableDeclarationOperand("int", "myVariable").setRightOperand(0).build();

Instruction inst14 = AssignmentInstructionHelper.builder()
			.setOperator(AssignmentKind.ASSIGN)
			.setLeftVariableDeclarationOperand("List<Integer>", "myFinalList", true // final_state
			).setRightOperand(CallInstructionHelper.createClassInstanciationInstruction("LinkedList<Integer"))
			.build();
----------

Generating code :

----------
int myVariable = 0;

List<Integer> myFinalList = new LinkedList<Intege>();
----------

[[Creation]]
=== Generating Creation Instruction

[[ArrayCreation]]
==== Generating Array Creation Instruction

Create a new array with an elements list : 

----------

ArrayInitializerInstruction inst1 = ArrayCreationHelper.createArray(1, 2, 3, 4, 5, 6);
// {1, 2, 3, 4, 5, 6}

ArrayInitializerInstruction inst2 = ArrayCreationHelper.createArray(
			ElementaryInstructionHelper.createInstruction("foo"),
			ElementaryInstructionHelper.createInstruction("bar"),
			ElementaryInstructionHelper.createInstruction("foobar"));
// {"foo", "bar", "foobar"}
----------

You can replace calling instructions by any other *IElementary* instructions.

Create a new array with type and dimensions :

----------
ElementaryInstruction inst3 = ArrayCreationHelper.builder("int").addDimensions(5, 2).build();
// new int[5][2]

ElementaryInstruction inst4 = ArrayCreationHelper.builder("Object").addFieldDimensions("myDimField","myDimField2")
			.addVariableDimensions("myDimVariable","myDimVariable2").build();
// new Object[this.myDimField][this.myDimField2][myDimVariable][myDimVariable2]

ElementaryInstruction inst5 = ArrayCreationHelper.builder("List<Object>")
			.addDimensions(CallInstructionHelper.createThisMethodCallInstruction("getDimension")).build();
// new List<Object>[this.getDimension()]
----------

You can replace calling instruction by any other *IElementary* instructions.

[[ClassCreation]]
==== Generating Class Instantiation Instruction

----------
AbstractMethodInstruction inst1 = CallInstructionHelper.createClassInstanciationInstruction("List<Integer>");
		
AbstractMethodInstruction inst2 = CallInstructionHelper.createClassInstanciationInstruction("Integer").addArgument("5");
----------

Generating code :

----------
new List<Integer>();

new Integer("5");
----------

See more about argument in the section <<Argument>>

[[MethodCall]]
=== Generating Method Call Instruction

Method call on the current object, a field or a variable :

----------
AbstractMethodInstruction inst1 = CallInstructionHelper.createThisMethodCallInstruction("currentObjectMethod");

AbstractMethodInstruction inst2 = CallInstructionHelper.createFieldMethodCallInstruction("myField",
			"fieldMethod");
			
AbstractMethodInstruction inst3 = CallInstructionHelper.createVariableMethodCallInstruction("myVar",
			"variableMethod");
----------

Generating code :

----------
this.currentObjectMethod();

this.myField.fieldMethod();

myVar.variableMethod();
----------

Super constructor or super method :

----------
AbstractMethodInstruction inst4 = CallInstructionHelper.createSuperConstructorCallInstruction();

AbstractMethodInstruction inst5 = CallInstructionHelper.createSuperMethodCallInstruction("superMethod");
----------

Generating code :

----------
super();

super.superMethod();
----------

Static method :

----------
AbstractMethodInstruction inst6 = CallInstructionHelper.createStaticMethodCallInstruction("MyClass",
			"staticMethod");
----------

Generating code :

----------
MyClass.staticMethod();
----------

Chaining method call :

----------
AbstractMethodInstruction inst7 = CallInstructionHelper.createCallMethodInstruction(
			CallInstructionHelper.createCallMethodInstruction(
				CallInstructionHelper.createThisMethodCallInstruction("firstMethod"), "secondMethod"),
			"thirdMethod");
----------

Generating code :

----------
this.firstMethod().secondMethod().thirdMethod();
----------

You can replace the original caller by any other *IElementary* instructions.

[[Argument]]
=== Add Argument To Generated Method

Add constant argument :

----------
AbstractMethodInstruction inst1 = CallInstructionHelper
			.createFieldMethodCallInstruction("myField", "someMethod").addArgument(42).addArgument("a string")
			.addArgument("false");

AbstractMethodInstruction inst2 = CallInstructionHelper
			.createVariableMethodCallInstruction("myVariable", "someMethod").addArgument('c').addNullArgument();
----------

Generating code :

----------
this.myField.someMethod(42, "a string", "false");

myVariable.someMethod('c', null);
----------

Add current object, field or variable as argument :

----------
AbstractMethodInstruction inst3 = CallInstructionHelper.createThisMethodCallInstruction("someMethod")
			.addFieldArgument("myField").addVariableArgument("myVar").addThisArgument();
----------


Generating code :

----------
this.someMethod(this.myField, myVar, this);
----------

Add complex argument :

----------
AbstractMethodInstruction inst4 = CallInstructionHelper.createStaticMethodCallInstruction("MyClass",
			"someMethod").addArgument(CallInstructionHelper.createThisMethodCallInstruction("otherMethod"));
----------


Generating code :

----------
MyClass.someMethod(this.otherMethod());
----------

You can replace the argument in complex example by any other *IElementary* instructions.

[[Return]]
=== Generating Return Instruction

We have two ways to create return instruction

==== With the dedicated helper : 

Constant Return Instruction :

----------
ComplexInstruction inst1 = ReturnInstructionHelper.createEmptyReturnInstruction();

ComplexInstruction inst2 = ReturnInstructionHelper.createNullReturnInstruction();

ComplexInstruction inst3 = ReturnInstructionHelper.createReturnInstruction(true);

ComplexInstruction inst4 = ReturnInstructionHelper.createReturnInstruction(12);

ComplexInstruction inst5 = ReturnInstructionHelper.createReturnInstruction('t');

ComplexInstruction inst6 = ReturnInstructionHelper.createReturnInstruction("foo");
----------

Generating code :

----------
return;

return null;

return true;

return 12;

return 't';

return "foo";
----------

This, Field, Variable Return Instruction :

----------
ComplexInstruction inst7 = ReturnInstructionHelper.createThisReturnInstruction();

ComplexInstruction inst8 = ReturnInstructionHelper.createVariableReturnInstruction("myVar");

ComplexInstruction inst9 = ReturnInstructionHelper.createFieldReturnInstruction("myField");
----------

Generating code :

----------
return this;

return myVar;

return this.myField;
----------

==== With any created IElementaryInstruction instruction

----------
AbstractMethodInstruction inst10 = CallInstructionHelper.createFieldMethodCallInstruction("myField",
			"fieldMethod");
ComplexInstruction inst11 = inst10.convertToReturnInstruction();
----------

Generating code :

----------
return this.myField.fieldMethod();
----------

[[Control]]
=== Generating Control Flow Instruction

[[If]]
==== Generating If Statement

----------
ComplexInstruction inst1 = IfInstructionHelper
			.builder(
					InfixOperationHelper.builder().setOperator(InfixExpressionKind.GREATER_EQUALS)
							.setLeftVariableOperand("myInt").setRightOperand(5).build()// if_condition
					,
					PostfixOperationHelper.builder().setOperator(PostfixExpressionKind.DECREMENT)
							.setVariableOperand("myInt").build() // then_first_instruction
					, ReturnInstructionHelper.createVariableReturnInstruction("myInt") // then_second_instruction
			)
			.addElseBlockInstruction(
					PostfixOperationHelper.builder().setOperator(PostfixExpressionKind.INCREMENT)
							.setVariableOperand("myInt").build() // else_instruction
			).build();
----------

Generating code : 
			
----------
if (myInt >= 5) {
	myInt--;
	return myInt;
} else {
	myInt++;
}
----------

[[Switch]]
==== Generating Switch Statement

Switch on a variable :

----------
ComplexInstruction inst1 = SwitchInstructionHelper
			.builderOnVariable("myVar")
			.addCaseBlock(2,
					true, // with_break
					PostfixOperationHelper.builder().setOperator(PostfixExpressionKind.INCREMENT)
							.setVariableOperand("myVar").build())
			.addFinalCaseBlock(
					PostfixOperationHelper.builder().setOperator(PostfixExpressionKind.DECREMENT)
							.setVariableOperand("myVar").build(),
					ReturnInstructionHelper.createVariableReturnInstruction("myVar")); // final_case
----------

Generating code : 
			
----------
switch (myVar) {
	case 2:
		myVar++;
		break;
	default:
		myVar--;
		return myVar;
}
----------
We doesn't need to call the *build()* method because the final case is necessary the last clause of the switch.

Switch on a field :

----------
ComplexInstruction inst2 = SwitchInstructionHelper
			.builderOnField("myField")
			.addCaseBlock('t', true) // with_break
			.addCaseVariableBlock("otherVariable", true,
					ReturnInstructionHelper.createVariableReturnInstruction("myField"))
			.addCaseBlock(CallInstructionHelper.createFieldMethodCallInstruction("otherField", "aMethod"), false, // no_break
					ReturnInstructionHelper.createThisReturnInstruction()).build();
----------

Generating code : 
			
----------
switch (this.myField) {
	case 't':
		break;
	case otherVariable:
		return myField;
		break;
	case this.otherField.aMethod():
		return this;
}
----------

Switch on any *IElementaryInstruction* instruction :

----------
ComplexInstruction inst3 = SwitchInstructionHelper
			.builder(CallInstructionHelper.createFieldMethodCallInstruction("myField", "fieldMethod"))
			.addCaseNullBlock(true, // with_break
					ReturnInstructionHelper.createNullReturnInstruction())
			.addFinalCaseBlock(ReturnInstructionHelper.createThisReturnInstruction());
----------

Generating code : 
			
----------
switch (this.myField.fieldMethod()) {
	case null:
		return null;
		break;
	default:
		return this;
}
----------

[[While]]
==== Generating While Statement

Generating while statement :

----------
ComplexInstruction inst1 = DoWhileInstructionHelper.createWhileInstruction(
			InfixOperationHelper.builder().setOperator(InfixExpressionKind.GREATER_EQUALS)
					.setLeftVariableOperand("myInt").setRightOperand(5).build() // while_condition
			,
			PostfixOperationHelper.builder().setOperator(PostfixExpressionKind.DECREMENT)
					.setVariableOperand("myInt").build(), // while_first_instruction
			CallInstructionHelper.createThisMethodCallInstruction("aMethod") // while_second_instruction
			);
----------

Generating code : 
			
----------
while (myInt >= 5) {
	myInt--;
	this.aMethod();
}
----------

Generating do statement :

----------
ComplexInstruction inst2 = DoWhileInstructionHelper.createDoInstruction(
			InfixOperationHelper.builder().setOperator(InfixExpressionKind.LESS_EQUALS)
					.setLeftVariableOperand("myInt").setRightOperand(10).build() // do_condition
			,
			PostfixOperationHelper.builder().setOperator(PostfixExpressionKind.INCREMENT)
					.setVariableOperand("myInt").build(), // do_first_instruction
			CallInstructionHelper.createThisMethodCallInstruction("aMethod") // do_second_instruction
			);
----------

Generating code : 
			
----------
do {
	myInt++;
	this.aMethod();
} while (myInt <= 10);
----------

[[ForLoop]]
==== Generating For Loop Statement

----------
ComplexInstruction inst1 = ForLoopInstructionHelper.createdForLoopInstruction(
			AssignmentInstructionHelper.builder().setOperator(AssignmentKind.ASSIGN)
					.setLeftVariableDeclarationOperand("int", "i").setRightOperand(0).build(), // for_initializer
			InfixOperationHelper.builder().setOperator(InfixExpressionKind.LESS).setLeftVariableOperand("i")
					.setRightVariableOperand("myArray.length").build(), // for_condition
			PostfixOperationHelper.builder().setOperator(PostfixExpressionKind.INCREMENT).setVariableOperand("i")
					.build(), // for_updater
			AssignmentInstructionHelper.builder().setOperator(AssignmentKind.ASSIGN)
					.setLeftFieldArrayOperand("myArray", "i").setRightVariableOperand("myInt").build(), // for_first_instruction
			PostfixOperationHelper.builder().setOperator(PostfixExpressionKind.INCREMENT)
					.setVariableOperand("myInt") // for_second_instruction
					.build());
----------

Or with builder :

----------
ComplexInstruction inst2 = ForLoopInstructionHelper
			.builderIntLoop("i")
			.initializeVariable(0)
			.setLoopCondition(InfixExpressionKind.LESS,
					ElementaryInstructionHelper.createVariableInstruction("myArray.length"))
			.setLoopUpdate(PostfixExpressionKind.INCREMENT)
			.addInstructions(
					AssignmentInstructionHelper.builder().setOperator(AssignmentKind.ASSIGN)
							.setLeftFieldArrayOperand("myArray", "i").setRightVariableOperand("myInt").build(),
					PostfixOperationHelper.builder().setOperator(PostfixExpressionKind.INCREMENT)
							.setVariableOperand("myInt").build()).build();
----------

Generating code :

----------
for (int i = 0 ; i<myArray.length ; i++){
	this.myArray[i]=myInt;
	myInt++;
}
----------

Other for loop creation :

----------
ComplexInstruction inst3 = ForLoopInstructionHelper.builderIntLoop("i")
			.setLoopCondition(InfixExpressionKind.LESS, 10).setLoopUpdate(AssignmentKind.PLUS_ASSIGN, 2).build();

ComplexInstruction inst4 = ForLoopInstructionHelper.builderIntLoop("i").initializeVariableWithField("myField")
			.setLoopVariableCondition(InfixExpressionKind.LESS, "myVariable")
			.setLoopVariableUpdate(AssignmentKind.PLUS_ASSIGN, "otherVariable").build();

ComplexInstruction inst5 = ForLoopInstructionHelper.builderIntLoop("i")
			.initializeVariableWithOtherVariable("myVariable")
			.setLoopFieldCondition(InfixExpressionKind.LESS, "myField")
			.setLoopFieldUpdate(AssignmentKind.PLUS_ASSIGN, "otherField").build();

ComplexInstruction inst6 = ForLoopInstructionHelper
			.builderIntLoop("i")
			.initializeVariable(CallInstructionHelper.createThisMethodCallInstruction("aMethod"))
			.setLoopCondition(InfixExpressionKind.LESS,
					CallInstructionHelper.createThisMethodCallInstruction("anOtherMethod"))
			.setLoopUpdate(AssignmentKind.PLUS_ASSIGN,
					CallInstructionHelper.createThisMethodCallInstruction("aMethodAgain")).build();
----------

Generating code : 
			
----------
for (i ; i<10 ; i += 2){}

for (int i = this.myField ; i < myVariable; i += otherVariable){}

for (int i = myVariable ; i < this.myField ; i += this.otherField){}

for (int i = this.aMethod() ; i < this.anOtherMethod() ; i+= this.aMethodAgain()){}
----------

You can replace the calling instruction by any other *IElementaryInstruction* instruction.

[[ForIterable]]
==== Generating For Iterable Statement

For iterable with existing variable :

----------
ComplexInstruction inst1 = ForIterableInstructionHelper.builder("variable")
			.setIterableFieldInstruction("myIterableField")
			.addInstructions(CallInstructionHelper.createVariableMethodCallInstruction("variable", "aMethod"))
			.build();
----------

Generating code : 
			
----------
for (variable : this.myIterableField){
	variable.aMethod();
}
----------

For iterable with variable creation :

----------
ComplexInstruction inst2 = ForIterableInstructionHelper.builder("Object", "variable")
			.setIterableVariableInstruction("myIterableVariable")
			.addInstructions(CallInstructionHelper.createVariableMethodCallInstruction("variable", "aMethod"))
			.build();
----------

Generating code : 
			
----------
for (Object variable : myIterableVariable){
	variable.aMethod();
}
----------

A more general example :

----------
ComplexInstruction inst3 = ForIterableInstructionHelper.builder("Object", "variable")
			.setIterableInstruction(CallInstructionHelper.createThisMethodCallInstruction("methodReturnIterable"))
			.build();
----------

Generating code : 
			
----------
for(Object variable : this.methodReturnIterable()){}
----------

You can replace the calling instruction by any other *IElementary* instruction.

[[Try/Catch]]
==== Generating Try/Catch Statement

----------
ComplexInstruction inst = TryCatchInstructionHelper
			.builder(CallInstructionHelper.createThisMethodCallInstruction("aMethodThrowingException"))
			.addTryBlockInstruction(
					CallInstructionHelper.createThisMethodCallInstruction("anotherMethodThrowingException"))
			.addCatchBlock("Exception1", "e1", CallInstructionHelper.createThisMethodCallInstruction("doSomething"))
			.addCatchBlock("Exception2", "e2",
					CallInstructionHelper.createThisMethodCallInstruction("doSomethingElse"),
					CallInstructionHelper.createSuperMethodCallInstruction("superMethod"))
			.addFinallyBlockInstruction(CallInstructionHelper.createThisMethodCallInstruction("doFinalThing"),
					CallInstructionHelper.createSuperMethodCallInstruction("superMethod")).build();
----------

Generating code : 
			
----------
try {
	this.aMethodThrowingException();
	this.anotherMethodThrowingException();
} catch (Exception1 e1) {
	this.doSomething();
} catch (Exception2 e2) {
	this.doSomethingElse();
	super.superMethod();
} finally {
	this.doFinalThing();
	super.superMethod();
}
----------

You can replace the calling instruction by any other *IComplexInstruction* instruction.

[[OtherInst]]
=== Generating Other Instruction

[[Parenthesis]]
==== Generating Parenthesized Instruction

On any *IElementaryInstruction*, you can add parenthesis :

----------
IElementaryInstruction inst = InfixOperationHelper.builder().setOperator(InfixExpressionKind.PLUS)
			.setLeftOperand(5).setRightOperand(10).build();

IElementaryInstruction inst1 = InfixOperationHelper.builder().setOperator(InfixExpressionKind.TIMES)
			.setLeftOperand(inst.withParentheses())
			.setRightOperand(2).build();
			
// (5 + 10) * 2;
----------

[[InstanceOf]]
==== Generating Instanceof Instruction

You can convert any *IElementaryInstruction* to an instanceof instruction :

----------
IElementaryInstruction inst = CallInstructionHelper.createThisMethodCallInstruction("aMethod")
			.convertToInstanceOfInstruction("MyType");
			
// this.aMethod() instanceof MyType
----------

[[Cast]]
==== Generating Cast Instruction

You can convert any *IElementaryInstruction* to a cast instruction :

----------
IElementaryInstruction inst = CallInstructionHelper.createThisMethodCallInstruction("aMethod")
			.convertToCastInstruction("MyType");

// (MyType) this.aMethod()
----------



